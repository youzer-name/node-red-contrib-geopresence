module.exports = function (RED) {
    function GeoPresenceNode(config) {
        RED.nodes.createNode(this, config);
        const node = this;

        const getValue = (context, type, key) => {
            if (type === "msg") return context.msg?.[key];
            if (type === "flow") return context.flow.get(key);
            if (type === "global") return context.global.get(key);
            return undefined;
        };

        const haversine = (lat1, lon1, lat2, lon2) => {
            const toRad = deg => deg * Math.PI / 180;
            const R = 6371;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) ** 2 +
                      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                      Math.sin(dLon / 2) ** 2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        };

        const parseTypedInput = (type, value) => {
            if (type === "bool") return value === "true";
            return value;
        };

        node.on('input', function (msg, send, done) {
            const context = {
                msg,
                flow: node.context().flow,
                global: node.context().global
            };

            let checkLat = getValue(context, config.checkLatType, config.checkLat);
            let checkLon = getValue(context, config.checkLonType, config.checkLon);

            const locationLat = parseFloat(config.locationLat);
            const locationLon = parseFloat(config.locationLon);
            const distance = parseFloat(config.distance);

            // Handle msg source with memory
            if (config.checkLatType === "msg" && config.checkLonType === "msg") {
                if (checkLat !== undefined) node.context().set("lastLat", parseFloat(checkLat));
                if (checkLon !== undefined) node.context().set("lastLon", parseFloat(checkLon));

                const storedLat = node.context().get("lastLat");
                const storedLon = node.context().get("lastLon");

                if (storedLat === undefined && storedLon === undefined) {
                    node.status({ fill: "yellow", shape: "dot", text: "waiting for lat/lon values" });
                    return;
                } else if (storedLat === undefined) {
                    node.status({ fill: "yellow", shape: "dot", text: "waiting for lat value" });
                    return;
                } else if (storedLon === undefined) {
                    node.status({ fill: "yellow", shape: "dot", text: "waiting for lon value" });
                    return;
                }

                checkLat = storedLat;
                checkLon = storedLon;
            } else {
                // flow/global: validate presence
                if (checkLat === undefined || checkLon === undefined) {
                    node.status({ fill: "red", shape: "ring", text: "flow or global variable missing" });
                    return;
                }
                checkLat = parseFloat(checkLat);
                checkLon = parseFloat(checkLon);
            }

            const dist = haversine(locationLat, locationLon, checkLat, checkLon);
            const isPresent = dist <= distance;

            const presenceMsg = isPresent
                ? parseTypedInput(config.presentMsgType, config.presentMsg)
                : parseTypedInput(config.notPresentMsgType, config.notPresentMsg);

            const statusColor = isPresent ? "green" : "gray";
            const statusText = `${config.location}: ${presenceMsg}`;

            node.status({ fill: statusColor, shape: "dot", text: statusText });

            const newMsg = RED.util.cloneMessage(msg);
            newMsg.payload = {
                ...msg.payload,
                name: config.location,
                presence: presenceMsg
            };

            send(newMsg);
            if (done) done();
        });
    }

    RED.nodes.registerType("geopresence", GeoPresenceNode);
};
